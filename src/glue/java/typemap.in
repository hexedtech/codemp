foreign_typemap!( //thanks @tasn on GitHub for the idea
	($p:r_type) <T> Result<T> => swig_i_type!(T) {
		$out = match $p {
			Ok(x) => {
				swig_from_rust_to_i_type!(T, x, ret)
				ret
			}
			Err(err) => {
				let (msg, exception_class) = match err {
					Error::Filler { message } => (
						message,
						swig_jni_find_class!(CODEMP_EXCEPTION, "com/codemp/intellij/exceptions/CodeMPException")
					),
					Error::Transport { status, message } => (
						format!("Status {}: {}", status, message),
						swig_jni_find_class!(TRANSPORT_EXCEPTION, "com/codemp/intellij/exceptions/lib/TransportException")
					),
					Error::InvalidState { msg } => (
						msg, swig_jni_find_class!(INVALID_STATE_EXCEPTION, "com/codemp/intellij/exceptions/lib/InvalidStateException")
					),
					Error::Deadlocked => (
						"WOOT deadlocked (safe to retry)!".to_string(),
						swig_jni_find_class!(DEADLOCKED_EXCEPTION, "com/codemp/intellij/exceptions/lib/DeadlockedException")
					),
					Error::Channel { send } => {
						let verb = if send { "sending" } else { "reading" };
						(
							format!("Error while {} message on channel: the channel was closed!", verb),
							swig_jni_find_class!(CHANNEL_EXCEPTION, "com/codemp/intellij/exceptions/lib/ChannelException")
						)
					}
				};
				jni_throw(env, exception_class, &msg);
				return <swig_i_type!(T)>::jni_invalid_value();
			}
		};
	};
	($p:f_type, unique_prefix="/*err*/") => "/*err*/swig_f_type!(T)" "swig_foreign_from_i_type!(T, $p)";
);
