from typing import Tuple, Optional, Callable

class Driver:
	"""
	this is akin to a big red button with a white "STOP" on top of it.
	it is used to stop the runtime
	"""
	def stop(self) -> None: ...


def init(logger_cb: Callable, debug: bool) -> Driver: ...

class RustPromise[T]:
	"""
	This is a class akin to a future, which wraps a join handle from a spawned
	task on the rust side. you may call .pyawait() on this promise to block
	until we have a result, or return immediately if we already have one.
	This only goes one way rust -> python.
	"""
	def pyawait(self) -> T: ...

class TextChange:
	"""
	Editor agnostic representation of a text change, it translate between internal
	codemp text operations and editor operations
	"""
	start: int
	end: int
	content: str

	def is_delete(self) -> bool: ...
	def is_insert(self) -> bool: ...
	def is_empty(self) -> bool: ...
	def apply(self, txt: str) -> str: ...


class BufferController:
	"""
	Handle to the controller for a specific buffer, which manages the back and forth
	of operations to and from other peers.
	"""
	async def content(self) -> str: ...
	async def send(self, start: int, end: int, txt: str) -> None: ...
	async def try_recv(self) -> Optional[TextChange]: ...
	async def recv(self) -> TextChange: ...
	async def poll(self) -> None: ...



class Cursor:
	"""
	An Editor agnostic cursor position representation
	"""
	start: Tuple[int, int]
	end: Tuple[int, int]
	buffer: str
	user: Optional[str] # can be an empty string


class CursorController:
	"""
	Handle to the controller for a workspace, which manages the back and forth of
	cursor movements to and from other peers
	"""
	async def send(self, path: str, start: Tuple[int, int], end: Tuple[int, int]) -> None: ...
	async def try_recv(self) -> Optional[Cursor]: ...
	async def recv(self) -> Cursor: ...
	async def poll(self) -> None: ...
	def stop(self) -> bool: ...


class Workspace:
	"""
	Handle to a workspace inside codemp. It manages buffers.
	A cursor is tied to the single workspace.
	"""
	async def create(self, path: str) -> None: ...
	async def attach(self, path: str) -> BufferController: ...
	def detach(self, path: str) -> bool: ...
	async def fetch_buffers(self) -> None: ...
	async def fetch_users(self) -> None: ...
	async def list_buffer_users(self, path: str) -> list[str]: ...
	async def delete(self, path: str) -> None: ...
	def id(self) -> str: ...
	def cursor(self) -> CursorController: ...
	def buffer_by_name(self, path: str) -> Optional[BufferController]: ...
	def buffer_list(self) -> list[str]: ...
	def filetree(self) -> list[str]: ...


class Client:
	"""
	Handle to the actual client that manages the session. It manages the connection
	to a server and joining/creating new workspaces
	"""
	def __new__(cls, host: str, username: str, password: str) -> None: ...
	def join_workspace(self, workspace: str) -> RustPromise: ...
	def leave_workspace(self, workspace: str) -> bool: ...
	def get_workspace(self, id: str) -> Workspace: ...
	def active_workspaces(self) -> list[str]: ...
	def user_id(self) -> str: ...
