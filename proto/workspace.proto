// Workspace effimero: sta in /tmp o proprio in memoria
// Workspace e` autenticato: come si decide mentre si rifa il server
// Workspace ha id univoco (stringa), usato per connettercisi
// Workspace implementera` access control:
//   * accedere al workspace
//   * i singoli buffer
//   - i metadati maybe????
// Workspace offre le seguenti features:
//  * listare i buffer DONE
//  * listare gli user connessi DONE
//  * creare buffers DONE REPLACE THE ONE ON buffer.proto
//  * NO ATTACH: responsabilita` del buffer service
//  * contiene metadata dei buffers:
//    * path
//    * data creazione
// Buffer id NON E` il path DONE
// BufferService NON ha metadata:
// Workspace tiene traccia di utenti attached (nel futuro) DONE






syntax = "proto3";

package workspace;
import "proto/user.proto";
import "proto/buffer.proto";

message Empty {}

message WorkspaceEvent {
	oneof event {
		CursorEvent cursor = 1;
		FileEvent file = 2;
		UserEvent user = 3;
	}
}

message WorkspaceFileTree {
	// list of strings may be more efficient but it's a lot more hassle
	string payload = 1; // spappolata di json
}

message WorkspaceUserList {
	repeated user.UserIdentity user = 1;
}

message WorkspaceMessage {
	int32 id = 1;
}


message TreeRequest {} // empty
message UserRequest {}
message CursorResponse{}
message UserListRequest{}

service Workspace {

	//
	rpc Create (BufferPayload)    returns (BufferCreateResponse);

	rpc ListBuffers (BufferListRequest) returns (BufferList);

	rpc ListUsers (UserListRequest) returns (UserList);

	//
	rpc Join (user.UserIdentity) returns (stream WorkspaceEvent);

	//
	rpc Tree (TreeRequest) returns (WorkspaceFileTree);

	//
	rpc Users (UserRequest) returns (WorkspaceUserList); // TODO could be handled by cursor  service

	// send cursor movement to server
	rpc Cursor (CursorEvent) returns (CursorResponse);
}

// a tuple indicating row and column
message RowCol {
	int32 row = 1;
	int32 col = 2;
}

// cursor position object
message CursorPosition {
	// cursor start position
	RowCol start = 1;
	// cursor end position
	RowCol end = 2;
}

// cursor event, with user id and cursor position
message CursorEvent {
	// user moving the cursor
	string user = 1;
	// path of current buffer this cursor is into
	string buffer = 2;
	// new cursor position
	repeated CursorPosition position = 3;
}

enum FileEventType {
	CREATE = 0;
	DELETE = 1;
	RENAME = 2;
}

message FileEvent {
	string buffer = 1;

	FileEventType type = 2;
}

enum UserEventType {
	JOIN = 0;
	LEAVE = 1;
}

message UserEvent {
	user.UserIdentity user = 1;

	UserEventType type = 2;
}



message BufferPayload {
	// buffer path to operate onto
	string path = 1;

	// user id that is requesting the operation
	user.UserIdentity user = 2;

	// optional buffer full content for replacing
	optional string content = 3;
}

message BufferCreateResponse {

	string status = 1;
}


message BufferListRequest{

}

message BufferList{
	repeated buffer.BufferView buffers = 1;
}

message UserList{
	repeated user.UserIdentity users = 1;
}